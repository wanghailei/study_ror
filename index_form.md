# Consolidating Rails CRUD Views into Index and Form: Feasibility Analysis



## **Overview of the Proposed View Structure**



The proposal is to reduce each resource’s views to just two templates: an index view (using Turbo Streams for list updates) and a form view (using a Turbo Frame for new, edit, **and** show). In practice, this means performing create, edit, and view (show) actions on the same page, reusing a single form partial for both editing and read-only display. The index.html.erb would render the list of records (and perhaps a placeholder for the form), and the form.html.erb partial would be loaded into a `<turbo-frame>` for creating or editing. For viewing a record’s details, the same form partial would be rendered in a read-only state instead of having a separate show template. This design aims to avoid full page navigation for CRUD, keeping the user in one context (much like a single-page application) . Turbo Streams would handle appending/prepending updated list items to the index, and Turbo Frames would handle in-place form interactions.

## **Potential Benefits (Pros)**





- **DRYness and Reuse:** Reusing one form partial for new, edit, and show can reduce duplicate code. Both new and edit already share a form partial in idiomatic Rails; extending this to show means all three actions rely on the same markup and layout for fields. This centralizes updates – changing a field’s layout or label happens in one place. A developer on Stack Overflow demonstrated this DRY approach by adding a readonly attribute to form fields and toggling it in the controller for show actions , allowing the same form to serve for editing (interactive) or viewing (read-only).
- **Reduced Context Switching:** Handling create and edit in-place on the index page improves user experience by avoiding page navigation. The Hotwire philosophy encourages performing actions without full page reloads to keep the user in context . By loading the form in a Turbo Frame on the index page (or in a modal frame), users can create or edit records without losing the surrounding context (e.g. the list). This can make the app feel faster and more cohesive, as the interaction is inline. It’s the same idea described in a Hotwire tutorial: instead of jumping to a separate page for “New” or “Edit,” those forms are presented inline on the index page, avoiding a disruptive context switch .
- **Single-Page Style Interactions:** With Turbo Frames and Streams, the CRUD interface can behave more like a single-page app. For example, upon creating a record, the server can respond with a Turbo Stream that appends the new item to the list (inside the index view) and possibly clears or hides the form. Editing an item could replace that item’s display with the form, then replace it back with updated content on save. This inline workflow can be smooth and fast. Users don’t have to navigate away to see changes, and if the same form partial is used for showing details, viewing or editing a record becomes a very similar interaction – possibly just a toggle between read-only and editable states.
- **Consistent Look and Feel:** Using one template for show/edit means the “show” view will have the same layout as the form. In some cases, this consistency might be desirable. For instance, an admin interface might not need a specially formatted read-only view – showing the record in form fields (or read-only text) with the same structure as the edit form could be sufficient. This could simplify UI decisions since you design one form layout for both viewing and editing.
- **Leverages Turbo’s Flexibility:** Turbo Frames allow a single server-rendered template to serve both full-page and partial content depending on how it’s loaded. In fact, Turbo can extract a frame from a full HTML response: if a user navigates via a frame, Turbo will grab the <turbo-frame> contents from the response and ignore the rest  . This means your form.html.erb (if it’s also used as a standalone show page) could include the form inside a frame, and when fetched inside the index page’s frame it would only render the form portion. Meanwhile, if the same URL is loaded directly (no frame), the user could get the full page (perhaps with the form partial rendered within a layout). This dual-use of templates is a feature of Turbo that can be tapped to keep view files minimal – one view can act as both a fragment and a full page  .

## **Challenges and Drawbacks (Cons)**



- **Complexity of Conditional Logic:** Merging the show view into the form partial introduces conditional logic or special handling within the partial. The form needs to “know” when to behave as an input form and when to behave as a read-only display. In practice, this means adding flags or checks for the context. For example, you might set a controller instance variable like @readonly = true in the show action, and in the form.html.erb use f.text_field :name, readonly: @readonly or disabled: @readonly on each field . Every field helper would need the readonly/disabled attribute, or you’d need to wrap sections in conditions (if @readonly ... else ...). This adds noise to the view code and risks making the partial harder to maintain. One developer noted that to reuse a form partial for viewing, they had to duplicate “disable” logic for every control, muddying the view with repetitive code . Such conditionals can grow unwieldy as the form grows (e.g. hiding/removing the submit button in show mode, handling links differently, etc.), potentially hurting **code clarity**.
- **Read-Only Form Fields UX:** Using a form layout to display data is not always ideal for user experience. If the show view is literally the form with fields disabled or marked read-only, it may look like a form in a disabled state rather than a nicely formatted read-only summary. Disabled or read-only inputs are typically greyed out and not selectable, which can be visually apparent and might confuse users (they might wonder if something is wrong). It might also be harder to copy text from disabled fields (depending on browser behavior). By contrast, a dedicated show view can present data in a more natural read-only format (paragraphs, tables, etc., with proper styling). So there’s a trade-off: convenience vs. optimal presentation. For **accessibility**, using many disabled form fields for display could be suboptimal (screen readers might announce them as form fields).
- **Maintainability as Requirements Grow:** What starts as the “same fields in edit and show” might diverge over time. Often, a show page isn’t just form fields; you might want to display related information, derived data, or a different layout (e.g. show an image thumbnail instead of an upload field, render a formatted address instead of separate address fields). Cramming these into the single form partial via more conditionals (e.g. if @readonly then display image tag, else file_field) can decrease maintainability. A Stack Overflow question from 2013 raised this concern – the author felt using the edit form for show was “difficult to maintain” once you start adding special cases . The accepted wisdom there was to favor partials (one for the form, another for display) over a single all-purpose template, to keep things clean and flexible. In essence, **separating concerns** can sometimes make maintenance easier: the show view can evolve independently (for example, showing extra read-only info or custom HTML) without being constrained by form markup.
- **Turbo Frame Complexity and Edge Cases:** When using Turbo Frames for navigation, each frame requires a matching <turbo-frame id="..."> in the response. Mixing full-page and frame-based rendering can introduce gotchas. For instance, if you click a link inside a frame that goes to a show action but the show template (now using the form partial) isn’t wrapped in a frame with the same ID, Turbo will log an error about missing content  . The Hotwire docs and examples often resolve this by making such links target _top, forcing a full-page load for the show page . In the two-template approach, if you intend to also show record details inline (within the index page) using the form partial, you’d need to ensure the response contains the appropriate frame. This might force you to wrap the form partial in a turbo_frame_tag even on the show action, or use JavaScript/stimulus to toggle between modes, which adds complexity. In short, Turbo’s requirement of frame ID matching can complicate a one-size-fits-all template if not carefully handled.
- **Deviation from Rails Conventions:** The Rails community has well-established conventions (convention over configuration). By default, Rails scaffolding generates separate templates for index, show, new, and edit (with a shared _form partial for new/edit). Most tutorials and open-source examples follow this pattern or some variant of it. Straying from this means new team members (or even your future self) might have a learning curve to understand the custom view structure. It’s not *wrong* to deviate, but it’s less familiar. Many Hotwire examples of “inline CRUD” still keep a partial for the item display and another partial for the form, swapping between them via Turbo Frames  . By condensing to one form partial for everything, you’re essentially combining what would traditionally be two partials (one for display, one for form) into one. This can confuse the separation of concerns between displaying data vs. soliciting input. The **community adoption** of a strictly two-template approach is low – it’s an unusual approach that isn’t discussed much in official guides or common blogs, aside from suggestions to reuse partials where practical. In community examples, you’ll often see a form partial reused for new/edit, and maybe a shared partial for show/index display, but not typically a single partial for all three. The fact that a question was asked on Stack Overflow about using one partial for edit and show   (and needed workarounds) indicates that the scenario isn’t straight “Rails Way.”
- **Testing and Context Handling:** Having one template serve multiple purposes means your test setup and rendering logic must account for the different contexts. For example, in controller tests or system tests, you’d verify that the form partial renders correctly in edit mode (with inputs enabled and a submit button) and in show mode (with inputs disabled or replaced by text, and no submit button). Ensuring that all branches of the conditional display logic work as intended might be a bit more involved than testing a dedicated show view. It’s not a deal-breaker, but it’s another aspect of maintenance to consider.

## **Examples and Community Insights**



Because this pattern is uncommon, there aren’t many high-profile open-source projects explicitly structured with only two view files per resource. However, pieces of the idea appear in various discussions:



- **Stack Overflow (2013):** A user asked how to avoid duplicating an address form partial for showing vs editing. The accepted answer proposed using a @readonly flag and adding readonly: true to each form field in the partial for show mode . This demonstrates the feasibility of the approach (it does work technically). Another answer suggested wrapping the fields in a fields_for @object do |f| block even on the show page to reuse the form partial  – essentially faking a form builder context without an actual form submission. These solutions, while clever, underscore that additional code is needed to make one partial cover both use cases. Notably, the question itself highlighted hesitation about maintainability, and the relatively low engagement on that Q&A suggests it’s not a very common practice (it was a niche question even then).
- **Formtastic GitHub Issue (2010):** An issue was raised requesting an easier way to “disable an entire form” for show views . The developer wanted to use the same form partial for editing and showing to “save time and reduce code” , but found it tedious to disable all fields manually. The fact this came up in a form builder gem’s issue tracker indicates real-world desire to reuse forms for display. It also highlights a pain point: without built-in support, one ends up writing boilerplate to disable or hide inputs in show mode . (In the end, the Rails core or popular gems did not introduce a one-step way to toggle an entire form’s editability – most likely because separate views or partials is the preferred solution.)
- **Hotwire/Turbo Community:** Many Hotwire examples show inline editing, which is closely related to this pattern. For instance, a Thoughtbot article on inline editing with Turbo Frames notes that Rails encourages reuse of partials, which can lead to needing conditional logic in views that are shared between contexts . In that article’s example, the show and index views both rendered the same _post partial for display, and the edit view rendered a form. They needed to **conditionally** wrap content in a turbo frame depending on context to avoid Turbo errors when switching between display and edit modes  . The key takeaway is that sharing view code between different actions is doable, but one must handle differences in context (like presence of a form or frame). The two-template proposal goes a step further by unifying not just index/show displays, but also the form itself with the display. This would likely require even more conditional logic (for whether to show a field as text or input).
- **Benito Serna’s Inline CRUD example (Rails + Hotwire):** Some community blog posts and examples (e.g. Benito Serna’s *“Inline CRUD with Rails and Hotwire”* example app) demonstrate performing all CRUD on one page. Those implementations typically use **two partials per item** – one partial for the item’s display state and another partial for the item’s form state – and then swap them via Turbo Frames. For example, the index might render each list item with a partial _item.html.erb and have a hidden frame for the form; clicking “Edit” replaces the item partial with _form.html.erb for that item. After update, it swaps back. While this achieves the “one page, two template types” idea, it *still* keeps display markup separate from form markup for clarity. Essentially, it’s a similar goal (minimal page loads) but a slightly different trade-off: more partials, less conditional logic. The community seems to gravitate to this approach (multiple partials for different states) rather than a single mega-partial, because it isolates complexity.
- **Turbo Frames Multi-purpose Views:** As mentioned, Turbo’s design allows a single view template to be used in multiple contexts. A comment by a Rails developer on Reddit praised that “this enables views in Rails to serve multiple purposes” – for example, the same HTML response can serve as a full page or just update a frame  . This is often achieved by including the relevant <turbo-frame> in the view. In a two-template scheme, you might leverage that by, say, having your form.html.erb wrapped in a turbo_frame_tag for the record (so it can replace a frame on the index page), but also allow the full show action to render that same partial inside a layout. Turbo will automatically strip away the layout when rendering inside an existing frame on the page. The net effect is you truly have one source of truth for the content. It’s powerful, but again, you must carefully ensure each context provides what Turbo expects (e.g. the frame with correct ID is present in the HTML).
- **Rails Conventional Approach:** It’s worth noting that most “Rails UIs” (scaffolds, admin gems like ActiveAdmin, etc.) **do** use a dedicated show view or at least a dedicated partial for show vs form. The prevailing approach to DRY views is to share what can be shared (e.g. use partials for forms, or for common display components), but not necessarily force one template to handle radically different modes. The community has widely adopted patterns like presenters or view components for complex view logic rather than relying on large, do-everything templates. This doesn’t mean the two-template idea is wrong; it’s more that Rails developers historically haven’t felt a strong need to collapse show into the form. With Hotwire making inline editing easier, some may experiment with unifying templates, but it’s still not mainstream. If you search the literature, you won’t find a “one form to rule them all” recipe in official guides or well-known gems – instead you find advice to use partials to keep code dry but separated by concern (one partial for form fields, another for displaying attributes)  .



## **Recommendations and Conclusion**

**Is it workable?** – Yes, technically this design can be made to work. With Turbo Frames/Streams, you can load the form partial for new and edit actions in a frame on the index page, and even use that same partial (with fields disabled or converted to plain text) for the show view. Developers have done it on a small scale and reported that it functions . If your CRUD interfaces are relatively simple (mostly form fields that map directly to displayed data) and you want a snappier, single-page feel, this approach can reduce the number of page transitions and files to manage.

However, **practicality** in the long run leans towards caution. The merged template will accumulate conditionals (for buttons, field states, etc.) which can make the code harder to read. It might save a few files in the short term, but at the cost of clarity. Future maintainers might find a single form/show template confusing: “Why is there a form tag in the show action? Why are all these fields disabled?” Unless thoroughly documented, it’s easy to trip up. The Rails way of separate views may be more verbose, but it clearly delineates purpose.

**Maintainability vs. DRY:** A guiding principle is to avoid “speculative DRY.” Don’t abstract or unify code until you’re sure the benefits outweigh the complexity. In this case, ask whether having one fewer file (a show view) justifies the extra logic in the form partial. In many cases, maintaining two very simple partials (one for show display, one for form) is actually easier than one partial that branches based on context. As one Rails expert succinctly advised: use partials to keep things DRY, but still keep enough separation to “readily address future changes” . If the show view ever needs a different presentation, having it tied to the form partial could become a hindrance.

**User Experience considerations:** Think about your users and the nature of your app. If the read-only view of a record should be optimized for reading (with nice formatting, perhaps combining fields or showing related info), you probably want a dedicated template or partial for it. On the other hand, if this is an admin backend or a tool mainly for managing data, showing fields in a form-like layout might be perfectly acceptable. You could even style the read-only state differently (e.g. via CSS classes when readonly is true) to make it look less like a disabled form and more like a detail view, but that again is extra work. It might be more user-friendly to have a clearly formatted show page. Consider also that **in-place editing** can be achieved without merging show and edit into one template – you can render the read-only view and swap it with the form on demand (Turbo Frames make this fairly straightforward, as demonstrated in many examples).

**Community adoption and teamwork:** If you’re working alone on a project, you have more freedom to choose unconventional patterns. If you’re on a team, it’s important to get buy-in for this approach. It’s non-standard enough that some team members might prefer to stick to separate views for clarity. There’s also less community reference material for the two-template style. Newcomers can’t easily google an error and find a solution tailored to this pattern; they’ll have to mentally translate from the typical multi-view pattern. So, adopting this should be a deliberate decision with team consensus. If you do go for it, maintain good documentation in your code (comments in the form partial explaining its dual role, etc.).

**Hybrid approach:** One compromise is to use two **partials** but still only two main templates: e.g., an index page and a combined “show/edit” page. In that scenario, you might not literally use the same exact partial for show and edit, but you still avoid separate pages by doing inline editing. For instance, render a _item partial for each record in the list (for display) and a _form partial for the form, and toggle them. This isn’t as minimal in terms of files, but it keeps the logic cleaner while achieving much of the single-page effect. Indeed, this is what many Hotwire demos do. It suggests that the Rails community tends to favor maintaining a clean separation between display view and form, even if both are rendered on the same page.

**Final verdict:** Structuring CRUD with only an index and a form template is **feasible** but comes with trade-offs in maintainability and clarity. It’s a workable solution for very CRUD-heavy interfaces where keeping the user on one page is paramount and the data presentation is simple. If you choose this route, implement it carefully:

- Use controller instance variables or local variables to indicate mode (:readonly flag or similar) and gate different elements in the view.
- Ensure Turbo Frame IDs and navigation are handled correctly (you may sometimes need data-turbo-frame="_top" on links to avoid Turbo mismatches when going to a full page ).
- Consider UX touches like visually distinguishing read-only mode, since an all-disabled form can be confusing. Even simply removing the form wrapper and rendering the fields as plain text in show mode (within the same template) might be better than a bunch of disabled inputs, for example.

If maintainability and clarity are top concerns, the more conventional approach (separate show view or partial) might serve better. As one commenter put it, *“Partials are your friend. You can keep your code DRY while maintaining enough flexibility to readily address future changes.”*  In other words, strive for balance. You can still **adopt Hotwire/Turbo** to avoid full page reloads (for a snappy UX) without literally merging all templates into one. Many developers achieve an excellent result with a few well-structured partials rather than a single monolithic template.

**Recommendation:** If you do implement the two-template pattern, do it in a limited context and evaluate it. See if the team finds it clear and if it truly eases maintenance. Be ready to refactor if it becomes too cumbersome. Given the low community adoption, treat it as an experimental optimization. It’s an interesting idea that can work in specific scenarios, but the classic approach (with some judicious partial reuse) is generally the safer, more clear path for the long term.

## **Sources**



- Hotrails Tutorial – Turbo Frames on one-page CRUD, avoiding separate new/edit pages 
- Thoughtbot Blog – Reusing partials between views and handling Turbo Frame conditions  
- Stack Overflow – Discussion of using one partial for edit and show (using readonly attributes)  
- Formtastic Issue – Developer requesting feature to reuse form for show (disabled fields)  
- Reddit (Hotwire discussion) – Turbo Frame grabs content from show page’s frame, allowing one template for multiple purposes  
- Rails Guides & Community – General best practices on using partials for maintainable views   (favor clarity with partials over overly DRY single templates)