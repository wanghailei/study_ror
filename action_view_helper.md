# Action View Helper

A helper is simply a module containing methods that assist a view. A helper extends the behavior of a template. ==Helper methods are output-centric, and they exist to generate HTML (or XML, or JavaScript).==

It’s always a good practice to use Rails helpers where they’re appropriate, even if it seems just as easy to hard-code the output you want.

While all view helpers are available to all controllers, it’s often good practice to organize helpers. ==By default, each controller gets its own helper module.==

## ``link_to``

link_to creates ==a hyperlink to another action== in your application.

```ruby
<%= link_to "Add Product", new_products_path %>
<%= link_to "Delete", product_path(@product), { class: "dangerous", method: 'delete' } %>
```

The ``:method`` option is a hack — it allows you to make the link look to the application as if the request were created by a `POST`, `PUT`, `PATCH`, or `DELETE`, rather than the normal `GET` method.

The most commonly used one is the `:confirm` option, which takes a short message. If present, an unobtrusive JavaScript driver will display the message and get the user’s confirmation before the link is followed.

```ruby
<%= link_to "Delete", product_path(@product), method: :delete, data: { confirm: 'Are you sure?' } %>
```

`link_to_if` and `link_to_unless` take a condition parameter, followed by the regular parameters to `link_to`. If the condition is true for `link_to_if` or false for `link_to_unless`, a regular link will be created using the remaining parameters. If not, the name will be added as plain text with no hyperlink.

### `link_to_unless_current`

The `link_to_unless_current` helper creates menus in sidebars where the current page name is shown as plain text and the other entries are hyperlinks:

```ruby
<ul><% %w{ create list edit save logout }.each do |action| %>
	<li><%= link_to_unless_current( action.capitalize, action: action ) %></li>
<% end %></ul>
```

The `link_to_unless_current` helper may also be passed a block that’s evaluated only if the current action is the action given, effectively providing an alternative to the link. There’s also a `current_page` helper method that simply tests whether the current page was generated by the given options.

The `button_to` method works the same as link_to but generates a button in a self-contained form rather than a straight hyperlink.

### `link_to image_tag`

```ruby
<%= link_to( image_tag("delete.png", size: "50x22"), product_path(@product), 
	method: :delete ), data: { confirm: "Are you sure?" } %>
```

## `button_to`



Use `button_to` when you want to create a button that submits to a URL, outside of any existing form. ==It creates its own `form` tag.== It's used for generating a new, standalone `<form>`. ==It does not work with form_with, neither automatically binds model data.==

==Use `f.submit` when you’re inside a `form` block.==

所以，不要試圖去修改 `ActionView::Helpers::FormTagHelper#submit_tag`。

## javascript_importmap_tags`

The `javascript_importmap_tags` method produces a list JavaScript filenames (assumed to live in `app/javascript`) which enables these resources to be imported by your application.

## `stylesheet_link_tag`

`<%= stylesheet_link_tag "inter-font", "data-turbo-track": "reload" %>`

`<%= stylesheet_link_tag "application", "data-turbo-track": "reload" %>”`

By default, image and style sheet assets are assumed to live in the `app/assets/images` and `app/assets/stylesheets` directories.



## capture

In Rails, the `capture` method is a helper that takes a block, executes it, and returns the generated output as a string.

```ruby
<% @greeting = capture do %>
	<p>Welcome! The date and time is <%= Time.current %></p>
<% end %>
```

Once captured, the content is stored in `@greeting`. You can then output it later in your view using `<%= @greeting %>`. This pattern is particularly useful when you want to build reusable view components or delay rendering.

### How come `capture` work globally in an app without an object?

In Rails, helper methods like `capture` are defined as instance methods within modules (such as `ActionView::Helpers::CaptureHelper`) that are mixed into the view context. ==When a view is rendered, it’s evaluated in the context of an instance of `ActionView::Base`==, which includes these helper modules. This makes methods like `capture` available “globally” within views without needing an explicit receiver.

To summarize:

**Module Inclusion**: Rails includes helper modules (like CaptureHelper) into ActionView::Base.

**View Context**: Each view is evaluated in an object (an instance of ActionView::Base) where these methods are accessible.

**Implicit Receiver**: When you call capture in a view, Ruby looks it up in the current object (the view instance) and finds it there.

This is why you can call capture directly in your ERB templates without specifying an object—it’s already part of the view’s context.

### `<% content_for %>`

`content_for` is a method of `ActionView::Helpers::CaputureHelper` ==for child views to inject content into parent layouts== at specific locations.

```ERB
<% content_for :title, "Products" %>
```

It is used to set the page title dynamically in Rails views. It stores content("Products") i==n a named block (`:title`)==, and makes it available to the layout template, therefore allows each page to set its own title.

In the view (e.g., `products/index.html.erb`):

```erb
<% content_for :title, "Products" %>
```

In the layout (e.g., `layouts/application.html.erb`):

```erb
<head>
	<title><%= yield(:title) || "BOS" %></title>
</head>
```

As a result, the browser tab/window's title becomes "Products" instead of a generic default.

Common use cases include:

```erb
# Set page title
<% content_for :title, "Edit Product" %>

# Set meta tags
<% content_for :meta_tags do %>
	<meta name="description" content="...">
<% end %>

# Add page-specific JavaScript
<% content_for :javascript do %>
	<script>...</script>
<% end %>
```



#### content_for 的用途顯然不止這些。

```ruby
<%= content_for?(:menu_body) ? yield(:menu_body) : render("shell/menu_body") %>
```

